---
id: package-core
title: Core
---

import { PackageHeader } from "@site/src/components/PackageHeader";

<PackageHeader version="1.1.3" packageName="core" containsTypeDefs />

A powerful and lightweight module composition strategy responsible for orchestrating your logic, enabling you to easily respect SOLID principles within your infinitely scalable app.

## Install

```bash
npm install --save @kaviar/core
```

## Basic Setup

The kernel is what orchestrates all of your bundles.

```typescript
import { Kernel } from "@kaviar/core";

const kernel = new Kernel();

kernel.init().then(() => {
  console.log("Kernel has been initialised.");
});
```

The Kernel is nothing without bundles. Bundles contain the logic.

```typescript
import { Bundle } from "@kaviar/core";

class AppBundle extends Bundle {
  async init() {
    // This is invoked when kernel is initialised
  }
}
```

You can add the bundle to the `kernel` in the constructor or later on:

```typescript
const kernel = new Kernel({
  bundles: [new AppBundle()],
});

// Add bundles outside constructor
kernel.addBundle(new OtherBundle());

kernel.init().then(() => {
  // ...
});
```

Initialisation process prepares and initialiases all the bundles registered inside it. You can regard your `Bundles` as groups of independent logic or strongly separated concerns.

Before we dive further into bundles and how we can manage them better, let's learn a bit about Dependency Injection (DI).

## Dependency Injection

An oversimplification of D.I. is that you don't depend on real stuff, you depend on references. For example, let's say you have a container that contains everything you need in your app, connection to the database, credentials, anything. And let's say you want to access the database service to do an insert, so instead of getting the service directly, you use the container:

```ts
container.set("database_service", MyDatabaseService);
const databaseService = container.get("database_service");
databaseService.insert({
  /* ... */
});
```

Now let's say the `databaseService` needs some credentials and a host to connect to. So instead of using a string directly or reading directly from env, it reads it from container:

```ts
container.set("database_uri", process.env.DATABASE_URI);
class DatabaseService {
  constructor(@Inject("database_uri") databseUri) {
    // Just a sample for illustration
    this.client = mongodb.connect(databaseUri);
  }
}
```

Now when we fetch DatabaseService from the container, it will automatically inject the dependencies.

So, we never instantiate via `new` we only fetch instances of our services through the container, and there's only one container which is provided by the `Kernel`. Above we showed how to use references as strings ("database_uri", "database_service") but references can be classes themselves or (as we'll see later on) tokens.

```typescript
import { Service } from "@kaviar/core";

const container = kernel.container;

@Service()
class B {}

@Service()
class A {
  // Automatic injection, you don't need to specify @Inject()
  constructor(b: B) {
    this.b = b;
  }
}
```

Now let's use them:

```typescript
const a = container.get(A); // note, A is the className, a is the instance
(instanceof a.b) === B; // true, a.b is an instance of B
```

Services are singletons, meaning it instantiates once:

```typescript
const a = container.get<A>(A);
a === container.get<A>(A); // true
```

You can also specify a list of parameters to the kernel, that can later be retrieved from the container

```js
new Kernel({
  parameters: {
    // Just some examples, they can be anything
    APPLICATION_URL: "https://www.google.com/",
    DEBUG: true,
  },
});

// Fetching them is getting the string wrapped in %%
const applicationUrl = container.get("%APPLICATION_URL%");

// Or you can get them via kernel.parameters
```

You can inject parameters from kernel, or others like this:

```typescript
@Service()
class A {
  // Inject via property, Note: it uses a function
  @Inject(() => "%DEBUG%")
  protected isDebug: boolean;

  // Inject via constructor
  constructor(@Inject("%APPLICATION_URL%") applicationUrl: string) {
    // Do something based on the context
  }
}
```

If you want to avoid having strings collide, you should use tokens as references:

```ts
import { Inject, Token } from "@kaviar/core";

const MY_SERVICE_TOKEN = new Token();

container.set(MY_SERVICE_TOKEN, B); // A simple B class
class A {
  // Property injection will be set after constructor
  @Inject(MY_SERVICE_TOKEN)
  b: B;

  // OR

  constructor(@Inject(MY_SERVICE_TOKEN) b: B) {
    // Both solutions work well (property injection/constructor injection)
    // Constructor is preferrable because you get access to the services inside it.
  }
}
```

## Async Event Management

What this is, is the ability to have event handlers that are async and can be blocking for the event propagation, and we finally have type-safety for our events.

```typescript
import { EventManager, Event } from "@kaviar/core";

class UserCreatedEvent extends Event<{
  userId: string;
}> {}

const manager = container.get(EventManager);

manager.addListener(UserCreatedEvent, e => {
  // The data provided in event's constructor is found in event.data property
  console.log(e.data.userId);
});

manager.emit(
  new UserCreatedEvent({
    userId: "XXX",
  })
);
```

Note that you also have `removeListener`, `addGlobalListener` and `removeGlobalListener`, also you can set the order in which the handlers are executed:

```typescript
manager.addListener(
  UserCreatedEvent,
  async e => {
    // Do something before any other handler executes
  },
  {
    order: -1000, // the lowest get executed first, by default order = 0
  }
);
```

You can also add a filter to the option, that will only allow certain "instances" of events. Let's say everytime you insert an object into the database you emit an event that contains also the collectionName in it. And you would like to listen to events for a certain collection:

```typescript
class ObjectInsertedEvent extends Event<{
  collectionName: string;
}> {}

manager.addListener(
  ObjectInsertedEvent,
  async e => {
    // Do something when the event
  },
  {
    filter: e => e.data.collectionName === "users",
  }
);
```

This is just a shorthand function so it allows your handler to focus on the task at hand rather than conditioning execution.

## Bundles

Ok, now that you've learned the basics of containers and async event management, it's time to understand where exactly to put these services and events. You should not have services or events outside a bundle. The bundle is what wraps them up.

Let's create a Bundle that handles our subcriptions:

```typescript
// Here we define the configuration the bundle can have
export interface ISaaSBundleConfig {
  subscriptionFee: number;
  currency: string;
}

// Here we define the config that is accepted by the bundle
// Think of this as a subset of the config above.
export interface ISaaSBundleRequiredConfig {
  subscriptionFee: number;
}

// Note that these configurations are optional.
class SaaSBundle extends Bundle<ISaaSBundleConfig, ISaaSBundleRequiredConfig> {
  defaultConfig = {
    // Not that this will be deeply merged with the config provided resulting into final config object
    currency: "USD",
  };

  async init() {
    // Access config here, example: this.config.currency
  }
}

// You benefit of autocompletion in the constructor
const bundle = new SaaSBundle({
  subscriptionFee: 10.0,
});

kernel.addBundle(bundle);
```

Bundles have the following lifecycle:

```typescript
class MyBundle extends Bundle<MyBundleConfig> {
  // validation is done when kernel starts the initialisation process
  async validate(config: MyBundleConfig) {}

  // Gives you the chance to hook into kernel and bundle-level events.
  // Runs before KernelBeforeInitEvent
  async hook() {}

  // Here you can basically prepare for initialisation, for example registering listeners, binding configurations to services.
  async prepare() {}

  // The final step in the bundle's lifecycle. This is where bundles usually start event loops (you start express), or connect to the database
  async init() {}
}
```

When we do `kernel.init()`, the following things happen:

1. We inject the `kernel` via `setKernel()` inside the Bundle instance
2. We await validation from all bundles
3. We start the hooking phase
4. We await preparation from all bundles
5. We await initialisation from all bundles

Kernel also emits the following events (name descriptive enough), and listeners are run in-sync:

- KernelBeforeInitEvent
- BundleBeforePrepareEvent
- BundleAfterPrepareEvent
- BundleBeforeInitEvent
- BundleAfterInitEvent
- KernelAfterInitEvent

So, in theory you have the chance to hook even more to the bundles you love:

```ts
import {
  Bundle,
  Events,
  EventManager,
  Event,
  BundleAfterPrepareEvent,
} from "@kaviar/core";

class MyBundle extends Bundle {
  hook() {
    // Let's say you want to do stuff, after MyOtherBundle gets prepared.
    const manager = this.container.get(EventManager);

    manager.addListener(
      BundleAfterPrepareEvent,
      async e => {
        // Do something
      },
      {
        filter: e => e.data.bundle instanceof MyOtherBundle,
      }
    );
  }
}
```

:::caution
Be careful if you emit certain events within the lifecycle of your bundles, because usually listener registration is done in prepare(), and if you emit an event before its handler was registered, it will not reach the listener.
:::

Let's say we have a bundle that needs an API key, for example, `MailBundle` needs some authentication parameters. The way we connect Bundle's config to the container is by setting some constants into the container which the services use in their instantiation.

```typescript
import { Inject, Service, Token, Bundle } from "@kaviar/core";

// {bundle}/constants.ts
const Constants = {
  API_KEY: new Token(),
};

// {bundle}/services/MailService.ts
@Service()
class MailService {
  constructor(@Inject(Constants.API_KEY) protected readonly apiKey: string) {}

  send() {
    // access this.apiKey
  }
}

// {bundle}/{bundle}.ts
interface IMailBundleConfig {
  apiKey: string;
}

class MailBundle extends Bundle<IMailBundleConfig> {
  async prepare() {
    // We do this in prepare() phase
    this.container.set(Constants.API_KEY, this.config.apiKey);
  }
}
```

## Listening to Events

In order to listen to events we have to register them somehow. This is why we introduce the concept of "warmup" for listeners.

```typescript
import { Listener, On } from "@kaviar/core";

// The base Listener class has a init() function that registers the events accordingly
class NotificationListener extends Listener {
  @On(UserAddedEvent, {
    /* order, filter */
  })
  onUserAdded(e: UserAddedEvent) {
    // Do something
  }
}
```

```typescript
class AppBundle extends Bundle {
  async prepare() {
    // Warmup forces service construction, and calls the init() function with no arguments
    // If the function exists.
    await this.warmup([NotificationListener]);
  }
}
```

## Exceptions

It's nice to never rely on string matching to see which exception was thrown, and it's nice to have typesafety as well. We recommend you always use this instead of the standard `Error`. The reason we changed the name to `Exception` instead of Error was to avoid confusion that these class would somehow extend the `Error` class.

```typescript
import { Exception } from "@kaviar/core";

class UserNotAuthorizedException extends Exception<{
  userId: string;
  context: string;
}> {
  getMessage() {
    const { userId, context } = this.data;

    return `User with id ${userId} was denied access while trying to access: ${context}`;
  }
}

throw new UserNotAuthorizedException({
  userId: "123",
  context: "viewUserProfile",
});
```

```typescript
try {
  viewUserProfile(profileId, { userId });
} catch (e) {
  if (e instanceof UserNotAuthorizedException) {
    // Do something, send an email!
  }
}
```

## Advanced Bundles

Keep your bundle easily modifiable by allowing injection of customised services. The strategy is to use an `abstract class` as a placeholder, but there are other solutions as well.

:::note When would you like to do this?
This would be suited when you expose a bundle in which you allow a certain service to be overriden.
:::

Let's think of a bundle that does some security thingies and they want to allow you to inject a custom hash function.

```typescript
abstract class HashService {
  hash(str: string) {
    return md5(str);
  }
}

// a placeholder, or declare hash abstract and implement it here, your choice or a mixture of both depending on the use-case
class DefaultHashService extends HashService {}

class SecurityBundle extends Bundle<{ hasher: HashService }> {
  static defaultConfig = {
    hasher: DefaultHashService,
  };

  prepare() {
    // We bind HashService, to use a different constructor
    this.container.set({ id: HashService, type: this.config.hasher });
  }
}

// adding it when you instantiate the bundle
kernel.addBundle(
  new SecurityBundle({
    hasher: ExtendedHashService,
  })
  // Now every service that depends on HashService will be overriden
);
```

This strategy is to explicitly state which hasher you want in the constructor, but in real-life scenarios, you'll most likely do this inside your own `AppBundle`:

```typescript
class SecurityExtensionBundle extends Bundle {
  async hook() {
    const manager = this.container.get(EventManager);

    // Before SecurityBundle is prepared, I can either modify the config
    manager.addListener(
      BundleBeforePrepareEvent,
      e => {
        const { bundle } = e.data;

        // We use the `updateConfig` command
        bundle.updateConfig({
          hasher: MyExtendedHasher,
        });
      },
      {
        filter: e => e.data.bundle instanceof SecurityBundle,
      }
    );
  }
}
```

This strategy may feel a bit obscure as you allow any bundle to modify the config at any stage, if you want to prevent such things happening to your bundle, you can do something like:

```typescript
class SecurityBundle extends Bundle {
  updateConfig() {
    throw new Error(
      `Please use the exposed methods of this bundle to override config.`
    );
  }

  setHasher(hasher: HashService): void {
    Object.assign(this.config, { hasher });
  }
}

// And now you call setHasher instead of updateConfig.
```

:::info
If you want to have more control over the `setHasher` you can use `bundle.phase` to ensure that it is set within the preparation or initialisation phase.
:::

```ts title="Phases for bundles and kernel"
export enum KernelPhase {
  DORMANT = "dormant",
  BUNDLE_SETUP = "bundle-setup",
  HOOKING = "hooking",
  PREPARING = "preparing",
  INITIALISING = "initialising",
  INITIALISED = "initialised",
  FROZEN = INITIALISED,
}

export enum BundlePhase {
  DORMANT = "dormant",
  SETUP = "setup",
  HOOKING = "hooking",
  HOOKED = "hooked",
  BEFORE_PREPARATION = "preparing",
  PREPARED = "prepared",
  BEFORE_INITIALISATION = "initialising",
  INITIALISED = "initialised",
  FROZEN = INITIALISED,
}
```
